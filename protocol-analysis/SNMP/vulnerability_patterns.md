# SNMP Vulnerability Patterns

**Purpose:** Common vulnerability patterns in SNMP implementations.

---

## üö® Critical Vulnerability Patterns

### 1. Community String Buffer Overflow (CWE-120)

**Pattern:**
```c
// VULNERABLE CODE
char community[32];
strcpy(community, packet->community);  // No bounds check!
```

**Detection in Ghidra:**
```python
# Find community string handling
community_strings = list_strings(filter="community", limit=50)
for s in community_strings:
    xrefs = get_xrefs_to(s['address'])
    for xref in xrefs:
        func = get_function_by_address(xref['from_address'])
        code = decompile_function(func['name'])
        
        # Look for strcpy/sprintf without bounds check
        if 'strcpy' in code or 'sprintf' in code:
            print(f"‚ö† Potential buffer overflow in {func['name']}")
```

**Fix:**
```c
// SAFE CODE
char community[32];
if (strlen(packet->community) >= sizeof(community)) {
    return ERROR_COMMUNITY_TOO_LONG;
}
strncpy(community, packet->community, sizeof(community) - 1);
community[sizeof(community) - 1] = '\0';
```

---

### 2. Path Traversal in MIB Access (CWE-22)

**Pattern:**
```c
// VULNERABLE CODE
char path[256];
sprintf(path, "/var/lib/snmp/mibs/%s.mib", oid_to_filename(oid));
FILE *f = fopen(path, "r");  // No path validation!
```

**Detection:**
```python
# Find file operations in SNMP handlers
file_ops = ["fopen", "open"]
for op in file_ops:
    funcs = search_functions_by_name(op, limit=20)
    for func in funcs:
        callers = get_function_callers(func['name'])
        for caller in callers:
            if 'snmp' in caller['name'].lower() or 'mib' in caller['name'].lower():
                code = decompile_function(caller['name'])
                # Check for path construction without validation
                if ('sprintf' in code or 'strcat' in code) and 'realpath' not in code.lower():
                    print(f"‚ö† Potential path traversal in {caller['name']}")
```

**Fix:**
```c
// SAFE CODE
char path[256];
char canonical[PATH_MAX];

sprintf(path, "/var/lib/snmp/mibs/%s.mib", oid_to_filename(oid));

// Canonicalize and validate
char *resolved = realpath(path, canonical);
if (!resolved) {
    return ERROR_INVALID_PATH;
}

// Check prefix
if (strncmp(canonical, "/var/lib/snmp/mibs/", 19) != 0) {
    return ERROR_ACCESS_DENIED;
}

FILE *f = fopen(canonical, "r");
```

---

### 3. Integer Overflow in BER Length Parsing (CWE-190)

**Pattern:**
```c
// VULNERABLE CODE
uint32_t length = parse_ber_length(packet);
char *buffer = malloc(length);  // length can be 0xFFFFFFFF!
memcpy(buffer, packet->data, length);  // Massive overflow
```

**Detection:**
```python
# Find BER/length parsing functions
parse_funcs = search_functions_by_name("parse_length", limit=20)
parse_funcs += search_functions_by_name("decode", limit=50)

for func in parse_funcs:
    code = decompile_function(func['name'])
    if 'malloc' in code and 'length' in code.lower():
        # Check for validation before malloc
        if 'if' not in code or 'MAX' not in code:
            print(f"‚ö† Potential integer overflow in {func['name']}")
```

**Fix:**
```c
// SAFE CODE
#define MAX_PDU_SIZE 65536

uint32_t length = parse_ber_length(packet);

// Validate before allocation
if (length == 0 || length > MAX_PDU_SIZE) {
    return ERROR_INVALID_LENGTH;
}

char *buffer = malloc(length);
if (!buffer) {
    return ERROR_OUT_OF_MEMORY;
}
memcpy(buffer, packet->data, length);
```

---

### 4. Command Injection in SET Handler (CWE-78)

**Pattern:**
```c
// VULNERABLE CODE
if (pdu_type == SNMP_SET) {
    char cmd[512];
    sprintf(cmd, "sysctl %s=%s", oid, value);
    system(cmd);  // User-controlled oid/value!
}
```

**Detection:**
```python
# Find SET handlers
set_handlers = search_functions_by_name("set", limit=100)
for func in set_handlers:
    if 'snmp' in func['name'].lower():
        code = decompile_function(func['name'])
        if 'system' in code or 'popen' in code or 'exec' in code:
            print(f"‚ö† Potential command injection in {func['name']}")
```

**Fix:**
```c
// SAFE CODE - Use execv instead of system
char *args[] = {"/usr/bin/sysctl", oid_param, value_param, NULL};
if (fork() == 0) {
    execv("/usr/bin/sysctl", args);  // No shell interpretation
    exit(1);
}
```

---

### 5. OID Integer Overflow (CWE-190)

**Pattern:**
```c
// VULNERABLE CODE
int parse_oid(char *oid_str) {
    int value = 0;
    while (isdigit(*oid_str)) {
        value = value * 10 + (*oid_str - '0');  // Can overflow!
        oid_str++;
    }
    return value;
}
```

**Detection:**
```python
# Find OID parsing functions
oid_funcs = search_functions_by_name("oid", limit=50)
for func in oid_funcs:
    code = decompile_function(func['name'])
    if 'while' in code and '*' in code and '+' in code:
        if 'INT_MAX' not in code and 'overflow' not in code.lower():
            print(f"‚ö† Potential integer overflow in {func['name']}")
```

**Fix:**
```c
// SAFE CODE
int parse_oid(char *oid_str) {
    long value = 0;
    while (isdigit(*oid_str)) {
        long new_value = value * 10 + (*oid_str - '0');
        if (new_value > INT_MAX) {
            return ERROR_OID_TOO_LARGE;
        }
        value = new_value;
        oid_str++;
    }
    return (int)value;
}
```

---

## üîç Vulnerability Detection Workflow

```python
# 1. Find all SNMP handlers
handlers = search_functions_by_name("handler", limit=100)
handlers += search_functions_by_name("snmp", limit=100)

# 2. For each handler, check for dangerous operations
for handler in handlers:
    code = decompile_function(handler['name'])
    
    # Check for buffer overflow
    if 'strcpy' in code or 'sprintf' in code or 'strcat' in code:
        print(f"CWE-120: Buffer overflow risk in {handler['name']}")
    
    # Check for path operations
    if 'fopen' in code or 'open' in code:
        if 'realpath' not in code.lower() and 'canonicalize' not in code.lower():
            print(f"CWE-22: Path traversal risk in {handler['name']}")
    
    # Check for command execution
    if 'system' in code or 'popen' in code or 'exec' in code:
        print(f"CWE-78: Command injection risk in {handler['name']}")
    
    # Check for memory allocation
    if 'malloc' in code or 'calloc' in code:
        if 'MAX' not in code:
            print(f"CWE-190: Integer overflow risk in {handler['name']}")
```

---

## üìã SNMP Vulnerability Checklist

### Community String Security
- [ ] Community string length validated before copy
- [ ] Safe string functions used (strncpy, strlcpy)
- [ ] Fixed-size buffer sufficiently large
- [ ] Null terminator explicitly set

### OID Processing
- [ ] OID component values checked for overflow
- [ ] OID string length validated
- [ ] MIB file paths validated (no "..")
- [ ] Path canonicalization before file access
- [ ] Prefix check after canonicalization

### BER/DER Decoding
- [ ] Length field validated before malloc
- [ ] Maximum length enforced (e.g., 65536)
- [ ] Integer overflow checked in arithmetic
- [ ] Nested structure depth limited

### SET Request Handling
- [ ] SET requests properly authenticated
- [ ] Values sanitized before use
- [ ] No system()/popen() with user data
- [ ] Use execv() instead of system() if needed
- [ ] Whitelist allowed operations

---

**Created:** 2025-10-12
**Next:** See `analysis_checklist.md` for systematic analysis workflow
